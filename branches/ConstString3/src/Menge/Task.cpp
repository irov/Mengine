#	include "Task.h"

namespace Menge
{
	//////////////////////////////////////////////////////////////////////////
	Task::Task()
		: m_complete(false)
		, m_interrupt(false)
	{
	}
	//////////////////////////////////////////////////////////////////////////
	Task::~Task()
	{
	}
	//////////////////////////////////////////////////////////////////////////
	void Task::destroy()
	{
		delete this;
	}
	//////////////////////////////////////////////////////////////////////////
	bool Task::main()
	{
		if( m_interrupt == true )
		{
			return false;
		}

		bool state = this->onMain();
		if( state == false )
		{
			m_interrupt = true;
			return false;
		}

		m_complete = true;
		return true;
	}
	//////////////////////////////////////////////////////////////////////////
	bool Task::isComplete() const
	{
		return m_complete;
	}
	//////////////////////////////////////////////////////////////////////////
	bool Task::isInterrupt() const
	{
		return m_interrupt;
	}
	//////////////////////////////////////////////////////////////////////////
	bool Task::onMain()
	{
		bool state = this->_onMain();
        if( state == false )
		{
			this->onInterrupt();
		}

		return state;
	}
	//////////////////////////////////////////////////////////////////////////
	bool Task::_onMain()
	{
        return true;
	}
	//////////////////////////////////////////////////////////////////////////
	bool Task::onRun()
	{
		for( TVectorTaskListener::iterator
			it = m_listeners.begin(),
			it_end = m_listeners.end();
		it != it_end;
		++it )
		{
			TaskListener * listener = *it;

			listener->onTaskRun( this );
		}
    
		bool state = this->_onRun();
        return state;
	}
	//////////////////////////////////////////////////////////////////////////
	bool Task::_onRun()
	{
		return true;
	}
	//////////////////////////////////////////////////////////////////////////
	void Task::onComplete()
	{
		for( TVectorTaskListener::iterator
			it = m_listeners.begin(),
			it_end = m_listeners.end();
		it != it_end;
		++it )
		{
			TaskListener * listener = *it;

			listener->onTaskComplete( this );
		}

		this->_onComplete();
	}
	//////////////////////////////////////////////////////////////////////////
	void Task::_onComplete()
	{
	}
	//////////////////////////////////////////////////////////////////////////
	void Task::cancel()
	{
		m_interrupt = true;
		this->onCancel();
	}
	//////////////////////////////////////////////////////////////////////////
	void Task::onCancel()
	{
		this->_onCancel();
	}
	//////////////////////////////////////////////////////////////////////////
	void Task::_onCancel()
	{
	}
	//////////////////////////////////////////////////////////////////////////
	void Task::update()
	{
		this->onUpdate();
	}
	//////////////////////////////////////////////////////////////////////////
	void Task::onUpdate()
	{
		this->_onUpdate();
	}
	//////////////////////////////////////////////////////////////////////////
	void Task::_onUpdate()
	{
	}
	//////////////////////////////////////////////////////////////////////////
	void Task::onInterrupt()
	{
		this->_onInterrupt();
	}
	//////////////////////////////////////////////////////////////////////////
	void Task::_onInterrupt()
	{
	}
	//////////////////////////////////////////////////////////////////////////
	void Task::addListener( TaskListener * _listener )
	{
		m_listeners.push_back( _listener );
	}
	//////////////////////////////////////////////////////////////////////////
	
}