#	include "NodeCore.h"
#	include "ObjectImplement.h"

#	include "SceneManager.h"

#	include "FileEngine.h"
#	include "ScriptEngine.h"

#	include "XmlParser.h"
#	include "ErrorMessage.h"

#	include <algorithm>

namespace Menge
{
	//////////////////////////////////////////////////////////////////////////
	NodeCore::NodeCore()
		: m_active(false)
		, m_scriptable(0)
	{
	}
	//////////////////////////////////////////////////////////////////////////
	NodeCore::~NodeCore()
	{
		delete m_scriptable;
	}
	//////////////////////////////////////////////////////////////////////////
	void NodeCore::destroy()
	{
		if( isScriptable() )
		{
			Holder<ScriptEngine>::hostage()
				->decref( this );
		}
		else
		{
			delete this;
		}
	}
	//////////////////////////////////////////////////////////////////////////
	bool NodeCore::activate()
	{

		if( m_active )
		{
			return true;
		}

		m_active = _activate();

		return m_active;
	}
	//////////////////////////////////////////////////////////////////////////
	void NodeCore::deactivate()
	{
		if( m_active )
		{
			_deactivate();
		}

		m_active = false;
	}
	//////////////////////////////////////////////////////////////////////////
	bool NodeCore::isActive()
	{
		return m_active;
	}
	//////////////////////////////////////////////////////////////////////////
	void NodeCore::setName(const std::string & _name)
	{
		m_name = _name;
	}
	//////////////////////////////////////////////////////////////////////////
	const std::string & NodeCore::getName()const
	{	
		return m_name;
	}
	//////////////////////////////////////////////////////////////////////////
	void NodeCore::setType(const std::string & _type)
	{
		m_type = _type;
	}
	//////////////////////////////////////////////////////////////////////////
	const std::string & NodeCore::getType()const
	{
		return m_type;
	}
	//////////////////////////////////////////////////////////////////////////
	void NodeCore::update(float _timing)
	{
		if( m_active == false )
		{
			return;
		}
		
		_update(_timing);
	}
	//////////////////////////////////////////////////////////////////////////
	void NodeCore::loader(TiXmlElement * _xml)
	{

	}
	//////////////////////////////////////////////////////////////////////////
	void NodeCore::debugRender()
	{
		//for( Node * children = getFirstChildren(); children; children = children->nextNode() )
		//{
		//	children->debugRender();
		//}

		_debugRender();
	}
	//////////////////////////////////////////////////////////////////////////
	void NodeCore::registerEvent( const std::string &_name, ScriptObject * _func  )
	{
		Eventable::registerEvent( _name, _func );
	}
	//////////////////////////////////////////////////////////////////////////
	ScriptObject * NodeCore::event( const std::string &_name )
	{
		return Eventable::event( _name );
	}
	//////////////////////////////////////////////////////////////////////////
	void NodeCore::setScriptable( ScriptObject * _scriptable )
	{
		m_scriptable = _scriptable;
	}
	//////////////////////////////////////////////////////////////////////////
	ScriptObject * NodeCore::getScriptable()
	{
		return m_scriptable;
	}
	//////////////////////////////////////////////////////////////////////////
	bool NodeCore::isScriptable() const
	{
		return m_scriptable != 0;
	}
	//////////////////////////////////////////////////////////////////////////
	void NodeCore::_debugRender()
	{
		//Empty
	}
	//////////////////////////////////////////////////////////////////////////
	bool NodeCore::_activate()
	{
		//Empty
		return true;
	}
	//////////////////////////////////////////////////////////////////////////
	void NodeCore::_deactivate()
	{
		//Empty
	}
	//////////////////////////////////////////////////////////////////////////
	void NodeCore::_update(float _timing)
	{
		//Empty
	}
}