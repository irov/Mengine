#	include "SoundNode.h"

#	include "ObjectImplement.h"

#	include "SoundSystemInterface.h"
#	include "SoundEngine.h"

#	include "XmlParser.h"
#	include "FileEngine.h"

//////////////////////////////////////////////////////////////////////////
OBJECT_IMPLEMENT(SoundNode);
//////////////////////////////////////////////////////////////////////////
SoundNode::SoundNode()
: m_interface(NULL)
{}
//////////////////////////////////////////////////////////////////////////
bool		SoundNode::play()
{
	return m_interface->play();
}
//////////////////////////////////////////////////////////////////////////
bool		SoundNode::pause()
{
	return m_interface->pause();
}
//////////////////////////////////////////////////////////////////////////
bool		SoundNode::stop()
{
	return m_interface->stop();
}
//////////////////////////////////////////////////////////////////////////
void		SoundNode::setLoop(bool _flag)
{
	m_interface->setLoop(_flag);
}
//////////////////////////////////////////////////////////////////////////
bool		SoundNode::isLooping() const
{
	return	m_interface->isLooping();
}
//////////////////////////////////////////////////////////////////////////
void		SoundNode::setGain(float _value)
{
	m_interface->setGain(_value);
}
//////////////////////////////////////////////////////////////////////////
float		SoundNode::getGain() const
{
	return	m_interface->getGain();
}
//////////////////////////////////////////////////////////////////////////
void		SoundNode::setPosition(const mt::vec3f& _position)
{
	m_interface->setPosition(_position.x,_position.y,_position.z);
}
//////////////////////////////////////////////////////////////////////////
mt::vec3f	SoundNode::getPosition() const
{
	const float* pos = m_interface->getPosition();
	return mt::vec3f(pos[0],pos[1],pos[2]);
}
//////////////////////////////////////////////////////////////////////////
void		SoundNode::setRelativeToListener(bool flag)
{
	m_interface->setRelativeToListener(flag);
}
//////////////////////////////////////////////////////////////////////////
bool		SoundNode::process()
{
	return m_interface->process();
}
//////////////////////////////////////////////////////////////////////////
bool		SoundNode::isRelativeToListener() const
{
	return	m_interface->isRelativeToListener();
}
//////////////////////////////////////////////////////////////////////////
bool		SoundNode::isPlaying() const
{
	return	m_interface->isPlaying();
}
//////////////////////////////////////////////////////////////////////////
double		SoundNode::getSizeSec()	const
{
	return	m_interface->getSizeSec();
}
//////////////////////////////////////////////////////////////////////////
void	SoundNode::_update(float _timing)
{
	m_interface->process();
}
//////////////////////////////////////////////////////////////////////////
void		SoundNode::loader(TiXmlElement * xml)
{
	XML_FOR_EACH_TREE(xml)
	{
		XML_CHECK_VALUE_NODE("Filename","Value",m_filename);
	}
}
//////////////////////////////////////////////////////////////////////////
bool		SoundNode::_compile()
{
	Keeper<SoundEngine>::hostage()->addSoundNode(m_interface,m_fileData,m_filename,0,true);
	//play(); //for test
	return	true;
}
//////////////////////////////////////////////////////////////////////////
void		SoundNode::_release()
{
	Keeper<SoundEngine>::hostage()->deleteSound(m_interface);
	Keeper<FileEngine>::hostage()->closeFile(m_fileData);
}